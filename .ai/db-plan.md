# Schemat Bazy Danych PostgreSQL dla AI-Smile

## 1. Typy Danych i Tabele

### Typy ENUM

W celu zapewnienia spójności danych dla typów symptomów i części ciała, zdefiniowano następujące typy `ENUM`.

```sql
CREATE TYPE public.symptom_type_enum AS ENUM (
        Tingle,
        Numbness,
        Cramps,
        FuckedUp
);

CREATE TYPE public.body_part_enum AS ENUM (
        Head,
        Neck,
        Back,
        Arms,
        Hands,        
        Legs        
);
```

### Tabela `profiles`

Przechowuje publiczne dane użytkowników, oddzielone od danych autentykacyjnych. Relacja jeden-do-jednego z tabelą `auth.users` Supabase.

```sql
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.profiles IS 'Przechowuje dane profilowe użytkowników.';
```

### Tabela `symptoms`

Główna tabela aplikacji, przechowująca wpisy o symptomach dodane przez użytkowników.

```sql
CREATE TABLE public.symptoms (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    occurred_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    symptom_type symptom_type_enum NOT NULL,
    body_part body_part_enum NOT NULL,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.symptoms IS 'Przechowuje wpisy o symptomach choroby użytkowników.';
```

## 2. Relacje Między Tabelami

-   **`profiles` ↔ `auth.users` (Jeden-do-jednego):**
    -   Każdy rekord w `auth.users` może mieć dokładnie jeden odpowiadający mu rekord w `public.profiles`.
    -   Połączenie jest realizowane przez klucz główny i obcy `profiles.id`, który jest referencją do `auth.users.id`.
    -   `ON DELETE CASCADE` zapewnia, że usunięcie użytkownika z `auth.users` automatycznie usunie jego profil.

-   **`symptoms` → `profiles` (Wiele-do-jednego):**
    -   Jeden użytkownik (profil) może mieć wiele wpisów o symptomach.
    -   Każdy wpis o symptomie należy do dokładnie jednego użytkownika.
    -   Relacja jest zdefiniowana przez klucz obcy `symptoms.user_id`, który wskazuje na `profiles.id`.
    -   `ON DELETE CASCADE` sprawia, że usunięcie profilu użytkownika powoduje usunięcie wszystkich jego wpisów o symptomach.

## 3. Indeksy

Indeksy zostały zaprojektowane w celu optymalizacji najczęstszych zapytań, takich jak sortowanie chronologiczne i filtrowanie.

-   **Indeks złożony do sortowania:**
    ```sql
    CREATE INDEX symptoms_user_id_occurred_at_idx ON public.symptoms(user_id, occurred_at DESC);
    ```
    *Uzasadnienie:* Znacząco przyspiesza pobieranie posortowanej chronologicznie (od najnowszych) listy symptomów dla konkretnego użytkownika, co jest głównym widokiem w aplikacji.

-   **Indeksy do filtrowania:**
    ```sql
    CREATE INDEX symptoms_symptom_type_idx ON public.symptoms(symptom_type);
    CREATE INDEX symptoms_body_part_idx ON public.symptoms(body_part);
    ```
    *Uzasadnienie:* Przyspieszają operacje filtrowania listy symptomów po typie objawu oraz części ciała.

## 4. Zasady Bezpieczeństwa (Row-Level Security)

RLS jest kluczowym mechanizmem zapewniającym, że użytkownicy mają dostęp wyłącznie do swoich danych.

### Włączenie RLS

```sql
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.symptoms ENABLE ROW LEVEL SECURITY;
```

### Polityki dla tabeli `profiles`

Użytkownicy mogą zarządzać wyłącznie swoim własnym profilem.

```sql
CREATE POLICY "Allow full access to own profile"
ON public.profiles
FOR ALL
USING (auth.uid() = id);
```

### Polityki dla tabeli `symptoms`

Użytkownicy mogą wykonywać wszystkie operacje CRUD wyłącznie na swoich własnych wpisach o symptomach.

```sql
CREATE POLICY "Allow full access to own symptoms"
ON public.symptoms
FOR ALL
USING (auth.uid() = user_id);
```

## 5. Automatyzacja i Dodatkowe Uwagi

### Automatyczne Tworzenie Profilu

Aby uprościć logikę aplikacji, proces tworzenia profilu jest zautomatyzowany na poziomie bazy danych za pomocą funkcji i wyzwalacza.

-   **Funkcja `handle_new_user`:**
    ```sql
    CREATE OR REPLACE FUNCTION public.handle_new_user()
    RETURNS TRIGGER AS $$
    BEGIN
      INSERT INTO public.profiles (id)
      VALUES (new.id);
      RETURN new;
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;
    ```

-   **Wyzwalacz `on_auth_user_created`:**
    ```sql
    CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_user();
    ```
*Opis:* Po każdej nowej rejestracji użytkownika w tabeli `auth.users`, wyzwalacz automatycznie uruchamia funkcję `handle_new_user`, która tworzy dla niego odpowiedni wpis w tabeli `public.profiles`, wiążąc oba rekordy.

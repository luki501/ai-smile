# Schemat Bazy Danych PostgreSQL dla AI-Smile

## 1. Typy Danych i Tabele

### Typy ENUM

W celu zapewnienia spójności danych dla typów symptomów i części ciała, zdefiniowano następujące typy `ENUM`.

```sql
CREATE TYPE public.symptom_type_enum AS ENUM (
        Tingle,
        Numbness,
        Cramps,
        FuckedUp
);

CREATE TYPE public.body_part_enum AS ENUM (
        Head,
        Neck,
        Back,
        Arms,
        Hands,        
        Legs        
);
```

### Tabela `profiles`

Przechowuje publiczne dane użytkowników, oddzielone od danych autentykacyjnych. Relacja jeden-do-jednego z tabelą `auth.users` Supabase.

```sql
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.profiles IS 'Przechowuje dane profilowe użytkowników.';
```

### Tabela `symptoms`

Główna tabela aplikacji, przechowująca wpisy o symptomach dodane przez użytkowników.

```sql
CREATE TABLE public.symptoms (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    occurred_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    symptom_type symptom_type_enum NOT NULL,
    body_part body_part_enum NOT NULL,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.symptoms IS 'Przechowuje wpisy o symptomach choroby użytkowników.';
```

### Tabela `reports`

Przechowuje wygenerowane raporty AI o symptomach użytkowników. Pozwala na archiwizację i ponowne przeglądanie wcześniej utworzonych analiz.

```sql
CREATE TABLE public.reports (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    content TEXT NOT NULL,
    period_start TIMESTAMPTZ NOT NULL,
    period_end TIMESTAMPTZ NOT NULL,
    period_type VARCHAR(20) NOT NULL
);

COMMENT ON TABLE public.reports IS 'Przechowuje historię raportów AI generowanych przez użytkowników.';
COMMENT ON COLUMN public.reports.period_type IS 'Typ okresu analizy: week, month, quarter';
COMMENT ON COLUMN public.reports.content IS 'Treść wygenerowanego raportu AI w formacie tekstowym';
```

## 2. Relacje Między Tabelami

-   **`profiles` ↔ `auth.users` (Jeden-do-jednego):**
    -   Każdy rekord w `auth.users` może mieć dokładnie jeden odpowiadający mu rekord w `public.profiles`.
    -   Połączenie jest realizowane przez klucz główny i obcy `profiles.id`, który jest referencją do `auth.users.id`.
    -   `ON DELETE CASCADE` zapewnia, że usunięcie użytkownika z `auth.users` automatycznie usunie jego profil.

-   **`symptoms` → `profiles` (Wiele-do-jednego):**
    -   Jeden użytkownik (profil) może mieć wiele wpisów o symptomach.
    -   Każdy wpis o symptomie należy do dokładnie jednego użytkownika.
    -   Relacja jest zdefiniowana przez klucz obcy `symptoms.user_id`, który wskazuje na `profiles.id`.
    -   `ON DELETE CASCADE` sprawia, że usunięcie profilu użytkownika powoduje usunięcie wszystkich jego wpisów o symptomach.

-   **`reports` → `profiles` (Wiele-do-jednego):**
    -   Jeden użytkownik (profil) może wygenerować wiele raportów AI.
    -   Każdy raport należy do dokładnie jednego użytkownika.
    -   Relacja jest zdefiniowana przez klucz obcy `reports.user_id`, który wskazuje na `profiles.id`.
    -   `ON DELETE CASCADE` zapewnia, że usunięcie profilu użytkownika automatycznie usuwa wszystkie jego raporty (zgodność z RODO).

## 3. Indeksy

Indeksy zostały zaprojektowane w celu optymalizacji najczęstszych zapytań, takich jak sortowanie chronologiczne i filtrowanie.

-   **Indeks złożony do sortowania:**
    ```sql
    CREATE INDEX symptoms_user_id_occurred_at_idx ON public.symptoms(user_id, occurred_at DESC);
    ```
    *Uzasadnienie:* Znacząco przyspiesza pobieranie posortowanej chronologicznie (od najnowszych) listy symptomów dla konkretnego użytkownika, co jest głównym widokiem w aplikacji.

-   **Indeksy do filtrowania:**
    ```sql
    CREATE INDEX symptoms_symptom_type_idx ON public.symptoms(symptom_type);
    CREATE INDEX symptoms_body_part_idx ON public.symptoms(body_part);
    ```
    *Uzasadnienie:* Przyspieszają operacje filtrowania listy symptomów po typie objawu oraz części ciała.

-   **Indeks do pobierania raportów użytkownika:**
    ```sql
    CREATE INDEX reports_user_id_created_at_idx ON public.reports(user_id, created_at DESC);
    ```
    *Uzasadnienie:* Optymalizuje pobieranie raportów użytkownika posortowanych chronologicznie (od najnowszych), co jest przydatne przy wyświetlaniu historii raportów.

-   **Indeks do wyszukiwania raportów według okresu:**
    ```sql
    CREATE INDEX reports_period_idx ON public.reports(user_id, period_start, period_end);
    ```
    *Uzasadnienie:* Przyspiesza zapytania wyszukujące raporty dla określonych przedziałów czasowych, co może być użyteczne przy analizie trendów długoterminowych.

## 4. Zasady Bezpieczeństwa (Row-Level Security)

RLS jest kluczowym mechanizmem zapewniającym, że użytkownicy mają dostęp wyłącznie do swoich danych.

### Włączenie RLS

```sql
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.symptoms ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;
```

### Polityki dla tabeli `profiles`

Użytkownicy mogą zarządzać wyłącznie swoim własnym profilem.

```sql
CREATE POLICY "Allow full access to own profile"
ON public.profiles
FOR ALL
USING (auth.uid() = id);
```

### Polityki dla tabeli `symptoms`

Użytkownicy mogą wykonywać wszystkie operacje CRUD wyłącznie na swoich własnych wpisach o symptomach.

```sql
CREATE POLICY "Allow full access to own symptoms"
ON public.symptoms
FOR ALL
USING (auth.uid() = user_id);
```

### Polityki dla tabeli `reports`

Użytkownicy mogą przeglądać, tworzyć, aktualizować i usuwać wyłącznie własne raporty AI.

```sql
CREATE POLICY "Allow full access to own reports"
ON public.reports
FOR ALL
USING (auth.uid() = user_id);
```

*Uwaga:* Polityka zapewnia pełną izolację danych między użytkownikami. Każdy użytkownik ma dostęp wyłącznie do raportów, które sam wygenerował.

## 5. Automatyzacja i Dodatkowe Uwagi

### Automatyczne Tworzenie Profilu

Aby uprościć logikę aplikacji, proces tworzenia profilu jest zautomatyzowany na poziomie bazy danych za pomocą funkcji i wyzwalacza.

-   **Funkcja `handle_new_user`:**
    ```sql
    CREATE OR REPLACE FUNCTION public.handle_new_user()
    RETURNS TRIGGER AS $$
    BEGIN
      INSERT INTO public.profiles (id)
      VALUES (new.id);
      RETURN new;
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;
    ```

-   **Wyzwalacz `on_auth_user_created`:**
    ```sql
    CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_user();
    ```
*Opis:* Po każdej nowej rejestracji użytkownika w tabeli `auth.users`, wyzwalacz automatycznie uruchamia funkcję `handle_new_user`, która tworzy dla niego odpowiedni wpis w tabeli `public.profiles`, wiążąc oba rekordy.

### Decyzje Projektowe dla Raportów AI

**Przechowywanie historii raportów:**
Raporty są zapisywane w bazie danych zamiast generowania ich za każdym razem od nowa. Takie podejście zapewnia:
- Możliwość ponownego przeglądania wcześniejszych analiz bez dodatkowych kosztów wywołań API
- Śledzenie zmian w czasie poprzez porównanie raportów z różnych okresów
- Szybszy dostęp do historycznych danych

**Struktura pola `content`:**
Treść raportu jest przechowywana jako `TEXT`, co pozwala na elastyczne formatowanie i przyszłe rozszerzenia (np. markdown, HTML).

**Typy okresów analizy:**
Pole `period_type` używa `VARCHAR(20)` zamiast ENUM, aby umożliwić łatwiejsze rozszerzanie o nowe typy okresów bez konieczności modyfikacji schematu bazy danych. Wartości dopuszczalne:
- `week` - ostatni tydzień
- `month` - ostatni miesiąc  
- `quarter` - ostatnie 3 miesiące

**Bezpieczeństwo danych:**
- Kaskadowe usuwanie (`ON DELETE CASCADE`) zapewnia zgodność z RODO - usunięcie konta użytkownika automatycznie usuwa wszystkie jego raporty
- RLS gwarantuje, że użytkownicy nie mają dostępu do raportów innych osób

**Optymalizacja wydajności:**
- Indeks `reports_user_id_created_at_idx` optymalizuje wyświetlanie historii raportów
- Indeks `reports_period_idx` przyspiesza wyszukiwanie raportów według przedziałów czasowych
- Brak dodatkowych tabel referencyjnych minimalizuje złożoność zapytań
